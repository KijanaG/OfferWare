{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst dotenv = require('dotenv');\n\nconst AWS = require('aws-sdk');\n\ndotenv.config();\nAWS.config.update({\n  region: 'us-west-2',\n  credentials: {\n    accessKeyId: process.env.accessKeyId,\n    secretAccessKey: process.env.secretAccessKey\n  }\n});\nvar docClient = new AWS.DynamoDB.DocumentClient();\nexport default (async (req, res) => {\n  const {\n    shopOrigin\n  } = req.cookies;\n  res.setHeader('Content-Type', 'application/json');\n  let success = null;\n\n  switch (req.method) {\n    case 'GET':\n      let fetchedProducts = await fetchProductsFromDB(shopOrigin);\n      res.status(200).json({\n        data: fetchedProducts ? fetchedProducts : []\n      });\n      break;\n\n    case 'POST':\n      let postProducts = req.body.products.map(prod => {\n        delete prod.__typename;\n        let id_arr = prod.id.split('/');\n        prod.global_id = id_arr[id_arr.length - 1];\n        let images = prod.images.edges.map(img => {\n          delete img.__typename;\n          delete img.node.__typename;\n          return img.node;\n        });\n        prod.images = images;\n        let variants = prod.variants.edges.map(variant => {\n          delete variant.__typename;\n          delete variant.node.__typename;\n          return variant.node;\n        });\n        prod.variants = variants;\n        prod.shopOrigin = shopOrigin;\n        return prod;\n      });\n      success = await postProductsToDB(postProducts, 'POST');\n      res.status(200).json({\n        success\n      });\n      break;\n\n    case 'PUT':\n      success = await postProductsToDB([req.body.product], 'PUT');\n      res.status(200).json({\n        success\n      });\n      break;\n\n    case 'PATCH':\n      success = await updateProductInDB(req.body.product, shopOrigin);\n      res.status(200).json({\n        success\n      });\n      break;\n\n    default:\n      res.setHeader('Allow', ['GET', 'POST']);\n      res.status(405).end(`Method ${method} Not Allowed.`);\n      break;\n  }\n});\n\nasync function updateProductInDB(product, shop) {\n  let {\n    title,\n    descriptionHtml,\n    images,\n    variants,\n    id\n  } = product;\n  const title_params = {\n    TableName: 'Shopify_Products',\n    FilterExpression: 'shopOrigin = :shop and id = :id',\n    ExpressionAttributeValues: {\n      ':shop': shop,\n      ':id': id\n    }\n  };\n  let awsRequest = docClient.scan(title_params);\n  let result = await awsRequest.promise();\n  let updatedProduct = null;\n\n  if (result.Items.length > 0) {\n    updatedProduct = _objectSpread({}, result.Items[0], {\n      title,\n      descriptionHtml\n    });\n    await updateDB(updatedProduct, images, variants);\n    return true;\n  }\n}\n\nasync function updateDB(updatedProduct, images, variants) {\n  let newImages = [];\n\n  for (let image of images.edges) newImages.push({\n    'altText': image.node.altText,\n    'originalSrc': image.node.originalSrc\n  });\n\n  updatedProduct.images = newImages;\n  let newVariants = [];\n\n  for (let variant of variants.edges) newVariants.push({\n    'title': variant.node.title,\n    'price': variant.node.price,\n    'compareAtPrice': variant.node.compareAtPrice\n  });\n\n  updatedProduct.variants = newVariants;\n  let updated_params = {\n    TableName: 'Shopify_Products',\n    Item: updatedProduct\n  };\n  let awsReq = await docClient.put(updated_params);\n  let res = awsReq.promise();\n  return;\n}\n\nasync function fetchProductsFromDB(shopOrigin, count = 0) {\n  const params = {\n    TableName: 'Shopify_Products',\n    FilterExpression: \"shopOrigin = :shop\",\n    ExpressionAttributeValues: {\n      ':shop': shopOrigin\n    }\n  };\n  const awsRequest = await docClient.scan(params);\n  const result = await awsRequest.promise();\n  if (result.Items.length > 0) return result.Items;else {\n    if (count == 3) return null;\n    await fetchProductsFromDB(shopOrigin, ++count);\n  }\n}\n\nasync function postProductsToDB(products, method, count = 0) {\n  if (products.length == 0) return true;\n\n  let Item = _objectSpread({}, products[products.length - 1], {\n    updatedAt: Date.now()\n  });\n\n  if (method == 'POST') {\n    Item = _objectSpread({}, Item, {\n      streetAddress: null,\n      city: null,\n      zipCode: null,\n      state: null,\n      transactionTotal: 0,\n      businessName: null,\n      merchantDescription: null,\n      email: null,\n      createdAt: Date.now(),\n      redeemedTotal: 0\n    });\n  }\n\n  const params = {\n    TableName: 'Shopify_Products',\n    Item\n  };\n  docClient.put(params, async (err, data) => {\n    if (err) {\n      if (count == 5) return false;\n      await postProductsToDB(products, method, ++count);\n    } else {\n      if (products.length > 0) {\n        products.pop();\n        await postProductsToDB(products, method, count);\n      }\n\n      return true;\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"module"}